{"version":3,"sources":["../src/stores/database.ts"],"sourcesContent":["/**\n * @adonisjs/session\n *\n * (c) AdonisJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport string from '@poppinss/utils/string'\nimport { MessageBuilder } from '@adonisjs/core/helpers'\nimport type { QueryClientContract } from '@adonisjs/lucid/types/database'\n\nimport debug from '../debug.js'\nimport type { SessionStoreWithTaggingContract, SessionData, TaggedSession } from '../types.js'\n\n/**\n * Database store to read/write session to SQL databases using Lucid\n */\nexport class DatabaseStore implements SessionStoreWithTaggingContract {\n  #client: QueryClientContract\n  #tableName: string\n  #ttlSeconds: number\n  #gcProbability: number\n\n  constructor(\n    client: QueryClientContract,\n    age: string | number,\n    options?: {\n      /**\n       * Defaults to \"sessions\"\n       */\n      tableName?: string\n\n      /**\n       * The probability (in percent) that garbage collection will be\n       * triggered on any given request. For example, 2 means 2% chance.\n       *\n       * Set to 0 to disable garbage collection.\n       *\n       * Defaults to 2 (2% chance)\n       */\n      gcProbability?: number\n    }\n  ) {\n    this.#client = client\n    this.#tableName = options?.tableName ?? 'sessions'\n    this.#ttlSeconds = string.seconds.parse(age)\n    this.#gcProbability = options?.gcProbability ?? 2\n    debug('initiating database store')\n  }\n\n  /**\n   * Run garbage collection to delete expired sessions.\n   * This is called based on gcProbability after writing session data.\n   */\n  async #collectGarbage(): Promise<void> {\n    if (this.#gcProbability <= 0) {\n      return\n    }\n\n    const random = Math.random() * 100\n    if (random < this.#gcProbability) {\n      debug('database store: running garbage collection')\n      const expiredBefore = new Date(Date.now())\n      await this.#client.from(this.#tableName).where('expires_at', '<=', expiredBefore).delete()\n    }\n  }\n\n  /**\n   * Parses and verifies session data using MessageBuilder\n   */\n  #parseSessionData(contents: string, sessionId: string): SessionData | null {\n    try {\n      return new MessageBuilder().verify<SessionData>(contents, sessionId)\n    } catch {\n      return null\n    }\n  }\n\n  /**\n   * Returns session data\n   */\n  async read(sessionId: string): Promise<SessionData | null> {\n    debug('database store: reading session data %s', sessionId)\n\n    const row = await this.#client.from(this.#tableName).where('id', sessionId).first()\n\n    if (!row) {\n      return null\n    }\n\n    /**\n     * Check if the session has expired. If so, delete it and return null.\n     */\n    const expiresAt = new Date(row.expires_at).getTime()\n    if (Date.now() > expiresAt) {\n      await this.destroy(sessionId)\n      return null\n    }\n\n    return this.#parseSessionData(row.data, sessionId)\n  }\n\n  /**\n   * Write session values to the database\n   */\n  async write(sessionId: string, values: Object): Promise<void> {\n    debug('database store: writing session data %s, %O', sessionId, values)\n\n    const message = new MessageBuilder().build(values, undefined, sessionId)\n    const expiresAt = new Date(Date.now() + this.#ttlSeconds * 1000)\n\n    await this.#client\n      .insertQuery()\n      .table(this.#tableName)\n      .insert({ id: sessionId, data: message, expires_at: expiresAt })\n      .knexQuery.onConflict('id')\n      .merge(['data', 'expires_at'])\n\n    await this.#collectGarbage()\n  }\n\n  /**\n   * Cleanup session by removing it\n   */\n  async destroy(sessionId: string): Promise<void> {\n    debug('database store: destroying session data %s', sessionId)\n\n    await this.#client.from(this.#tableName).where('id', sessionId).delete()\n  }\n\n  /**\n   * Updates the session expiry\n   */\n  async touch(sessionId: string): Promise<void> {\n    debug('database store: touching session data %s', sessionId)\n\n    const expiresAt = new Date(Date.now() + this.#ttlSeconds * 1000)\n\n    await this.#client\n      .from(this.#tableName)\n      .where('id', sessionId)\n      .update({ expires_at: expiresAt })\n  }\n\n  /**\n   * Tag a session with a user ID.\n   * Uses UPSERT to handle both existing and new sessions.\n   */\n  async tag(sessionId: string, userId: string): Promise<void> {\n    debug('database store: tagging session %s with user %s', sessionId, userId)\n\n    const data = new MessageBuilder().build({}, undefined, sessionId)\n    const expiresAt = new Date(Date.now() + this.#ttlSeconds * 1000)\n\n    await this.#client\n      .insertQuery()\n      .table(this.#tableName)\n      .insert({ id: sessionId, user_id: userId, data, expires_at: expiresAt })\n      .knexQuery.onConflict('id')\n      .merge(['user_id'])\n  }\n\n  /**\n   * Converts a database row to a TaggedSession object\n   */\n  #rowToTaggedSession(row: { id: string; data: string }): TaggedSession | null {\n    const data = this.#parseSessionData(row.data, row.id)\n    if (!data) return null\n\n    return { id: row.id, data }\n  }\n\n  /**\n   * Get all sessions for a given user ID (tag)\n   */\n  async tagged(userId: string): Promise<TaggedSession[]> {\n    debug('database store: getting sessions tagged with user %s', userId)\n\n    const rows = await this.#client\n      .from(this.#tableName)\n      .select('id', 'data')\n      .where('user_id', userId)\n      .where('expires_at', '>', new Date())\n\n    return rows.map((row) => this.#rowToTaggedSession(row)).filter((session) => session !== null)\n  }\n}\n"],"mappings":"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","names":[]}