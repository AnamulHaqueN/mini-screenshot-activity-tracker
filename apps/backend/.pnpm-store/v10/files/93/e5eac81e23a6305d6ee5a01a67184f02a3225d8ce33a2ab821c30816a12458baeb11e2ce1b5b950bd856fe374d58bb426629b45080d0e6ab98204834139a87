{"version":3,"sources":["../src/stores/redis.ts"],"sourcesContent":["/**\n * @adonisjs/session\n *\n * (c) AdonisJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport string from '@poppinss/utils/string'\nimport { MessageBuilder } from '@adonisjs/core/helpers'\nimport type { Connection } from '@adonisjs/redis/types'\n\nimport debug from '../debug.js'\nimport type { SessionStoreWithTaggingContract, SessionData, TaggedSession } from '../types.js'\n\n/**\n * Redis store to read/write session to Redis\n */\nexport class RedisStore implements SessionStoreWithTaggingContract {\n  #connection: Connection\n  #ttlSeconds: number\n\n  constructor(connection: Connection, age: string | number) {\n    this.#connection = connection\n    this.#ttlSeconds = string.seconds.parse(age)\n    debug('initiating redis store')\n  }\n\n  /**\n   * Returns the key for a user's tag set (stores session IDs for a user)\n   */\n  #getTagKey(userId: string): string {\n    return `session_tag:${userId}`\n  }\n\n  /**\n   * Verify contents with the session id and return them as an object. The verify\n   * method can fail when the contents is not JSON\n   */\n  #parseSessionData(contents: string, sessionId: string): SessionData | null {\n    try {\n      return new MessageBuilder().verify<SessionData>(contents, sessionId)\n    } catch {\n      return null\n    }\n  }\n\n  /**\n   * Returns session data\n   */\n  async read(sessionId: string): Promise<SessionData | null> {\n    debug('redis store: reading session data %s', sessionId)\n\n    const contents = await this.#connection.get(sessionId)\n    if (!contents) {\n      return null\n    }\n\n    return this.#parseSessionData(contents, sessionId)\n  }\n\n  /**\n   * Write session values to redis\n   */\n  async write(sessionId: string, values: Record<string, any>): Promise<void> {\n    debug('redis store: writing session data %s, %O', sessionId, values)\n\n    const message = new MessageBuilder().build(values, undefined, sessionId)\n    await this.#connection.setex(sessionId, this.#ttlSeconds, message)\n  }\n\n  /**\n   * Cleanup session by removing it\n   */\n  async destroy(sessionId: string): Promise<void> {\n    debug('redis store: destroying session data %s', sessionId)\n    await this.#connection.del(sessionId)\n  }\n\n  /**\n   * Updates the value expiry\n   */\n  async touch(sessionId: string): Promise<void> {\n    debug('redis store: touching session data %s', sessionId)\n    await this.#connection.expire(sessionId, this.#ttlSeconds)\n  }\n\n  /**\n   * Tag a session with a user ID\n   */\n  async tag(sessionId: string, userId: string): Promise<void> {\n    debug('redis store: tagging session %s with user %s', sessionId, userId)\n    await this.#connection.sadd(this.#getTagKey(userId), sessionId)\n  }\n\n  /**\n   * Processes a single session result from the pipeline\n   */\n  #processSessionResult(options: { sessionId: string; contents: string | null }): {\n    session: TaggedSession | null\n    isInvalid: boolean\n  } {\n    if (!options.contents) return { session: null, isInvalid: true }\n\n    const data = this.#parseSessionData(options.contents, options.sessionId)\n    if (!data) return { session: null, isInvalid: true }\n\n    return { session: { id: options.sessionId, data }, isInvalid: false }\n  }\n\n  /**\n   * Fetches session contents for multiple session IDs using a pipeline\n   */\n  async #fetchSessionContents(sessionIds: string[]): Promise<Array<string | null>> {\n    const pipeline = this.#connection.pipeline()\n    sessionIds.forEach((sessionId) => pipeline.get(sessionId))\n    const results = await pipeline.exec()\n\n    return results?.map((result) => result[1] as string | null) ?? []\n  }\n\n  /**\n   * Removes invalid session IDs from the user's tag set\n   */\n  async #cleanupInvalidSessions(userId: string, invalidSessionIds: string[]): Promise<void> {\n    if (invalidSessionIds.length === 0) return\n\n    await this.#connection.srem(this.#getTagKey(userId), ...invalidSessionIds)\n  }\n\n  /**\n   * Get all sessions for a given user ID (tag)\n   */\n  async tagged(userId: string): Promise<TaggedSession[]> {\n    debug('redis store: getting sessions tagged with user %s', userId)\n\n    const sessionIds = await this.#connection.smembers(this.#getTagKey(userId))\n    if (sessionIds.length === 0) return []\n\n    const contents = await this.#fetchSessionContents(sessionIds)\n\n    const results = sessionIds.map((sessionId, index) =>\n      this.#processSessionResult({ sessionId, contents: contents[index] })\n    )\n\n    const validSessions = results.filter((r) => r.session !== null).map((r) => r.session!)\n    const invalidSessionIds = results\n      .map((result, index) => (result.isInvalid ? sessionIds[index] : null))\n      .filter((id) => id !== null)\n\n    await this.#cleanupInvalidSessions(userId, invalidSessionIds)\n\n    return validSessions\n  }\n}\n"],"mappings":"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","names":[]}