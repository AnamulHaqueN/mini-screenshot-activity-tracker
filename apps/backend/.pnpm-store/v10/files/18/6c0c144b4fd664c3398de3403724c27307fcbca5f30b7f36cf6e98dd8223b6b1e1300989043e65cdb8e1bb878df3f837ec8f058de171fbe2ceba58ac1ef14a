{"version":3,"sources":["../src/session_collection.ts"],"sourcesContent":["/**\n * @adonisjs/session\n *\n * (c) AdonisJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport debug from './debug.js'\nimport { E_SESSION_TAGGING_NOT_SUPPORTED } from './errors.js'\nimport type {\n  ResolvedSessionConfig,\n  SessionData,\n  SessionStoreWithTaggingContract,\n  TaggedSession,\n} from './types.js'\n\n/**\n * SessionCollection provides APIs for programmatic session\n * management. It allows reading, destroying, and tagging\n * sessions without an HTTP context.\n *\n * @example\n * ```ts\n * import app from '@adonisjs/core/services/app'\n * import { SessionCollection } from '@adonisjs/session'\n *\n * const sessionCollection = await app.container.make(SessionCollection)\n *\n * // List all sessions for a user\n * const sessions = await sessionCollection.tagged(String(user.id))\n *\n * // Destroy a specific session\n * await sessionCollection.destroy(sessionId)\n * ```\n */\nexport class SessionCollection {\n  #store: SessionStoreWithTaggingContract\n\n  constructor(config: ResolvedSessionConfig) {\n    const storeFactory = config.stores[config.store]\n    this.#store = storeFactory(null as any, config) as SessionStoreWithTaggingContract\n  }\n\n  /**\n   * Check if the current store supports tagging\n   */\n  supportsTagging(): boolean {\n    return 'tag' in this.#store && 'tagged' in this.#store\n  }\n\n  /**\n   * Returns the session data for the given session ID,\n   * or null if the session does not exist\n   */\n  async get(sessionId: string): Promise<SessionData | null> {\n    debug('session collection: getting session data %s', sessionId)\n    return this.#store.read(sessionId)\n  }\n\n  /**\n   * Destroys a session by its ID\n   */\n  async destroy(sessionId: string): Promise<void> {\n    debug('session collection: destroying session %s', sessionId)\n    return this.#store.destroy(sessionId)\n  }\n\n  /**\n   * Tag a session with a user ID.\n   * Only supported by Memory, Redis and Database stores.\n   */\n  async tag(sessionId: string, userId: string): Promise<void> {\n    debug('session collection: tagging session %s with user %s', sessionId, userId)\n    if (!this.supportsTagging()) throw new E_SESSION_TAGGING_NOT_SUPPORTED()\n\n    return (this.#store as SessionStoreWithTaggingContract).tag(sessionId, userId)\n  }\n\n  /**\n   * Get all sessions for a given user ID (tag).\n   * Only supported by Memory, Redis and Database stores.\n   */\n  async tagged(userId: string): Promise<TaggedSession[]> {\n    debug('session collection: getting sessions tagged with user %s', userId)\n    if (!this.supportsTagging()) throw new E_SESSION_TAGGING_NOT_SUPPORTED()\n\n    return (this.#store as SessionStoreWithTaggingContract).tagged(userId)\n  }\n}\n"],"mappings":";;;;;;;;AAqCO,IAAM,oBAAN,MAAwB;AAAA,EAC7B;AAAA,EAEA,YAAY,QAA+B;AACzC,UAAM,eAAe,OAAO,OAAO,OAAO,KAAK;AAC/C,SAAK,SAAS,aAAa,MAAa,MAAM;AAAA,EAChD;AAAA;AAAA;AAAA;AAAA,EAKA,kBAA2B;AACzB,WAAO,SAAS,KAAK,UAAU,YAAY,KAAK;AAAA,EAClD;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,MAAM,IAAI,WAAgD;AACxD,kBAAM,+CAA+C,SAAS;AAC9D,WAAO,KAAK,OAAO,KAAK,SAAS;AAAA,EACnC;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,QAAQ,WAAkC;AAC9C,kBAAM,6CAA6C,SAAS;AAC5D,WAAO,KAAK,OAAO,QAAQ,SAAS;AAAA,EACtC;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,MAAM,IAAI,WAAmB,QAA+B;AAC1D,kBAAM,uDAAuD,WAAW,MAAM;AAC9E,QAAI,CAAC,KAAK,gBAAgB,EAAG,OAAM,IAAI,gCAAgC;AAEvE,WAAQ,KAAK,OAA2C,IAAI,WAAW,MAAM;AAAA,EAC/E;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,MAAM,OAAO,QAA0C;AACrD,kBAAM,4DAA4D,MAAM;AACxE,QAAI,CAAC,KAAK,gBAAgB,EAAG,OAAM,IAAI,gCAAgC;AAEvE,WAAQ,KAAK,OAA2C,OAAO,MAAM;AAAA,EACvE;AACF;","names":[]}